The HTTP endpoints to support this game will look like this:

POST to /start_game  ∆
This request begins a game. The response says Good luck! and starts a game.

GET to /game
A request to this verb/path combo tells us:

a) how many guesses have been taken.
b) if a guess has been made, it tells what the guess was and whether it was too
high, too low, or correct

POST to /game
This is how we make a guess. The request includes a parameter named guess.
The server stores the guess and sends the user a redirect response, causing the
client to make a GET to /game.


So far all of the requests we’ve dealt with have been using HTTP’s GET verb. A
GET request signifies fetching rather than sending information. POST requests,
on the other hand, signify sending information. In this section we’ll be using
post requests to allow users to send us data to interact with the simple HTTP
game.

So what do we need to do differently when handling POST requests vs. GETs?
Fortunately, most of the other parsing we’ve done will remain the same – headers,
 paths, parameters, etc. When reading a POST request, however, we also need to
 give attention to the request body.

Remember that in an HTTP request the body is separated from the headers with a
blank line – in our basic parsing so far, encountering this blank line is how
we know when we’re done reading headers. Everything after the blank line, then,
is the body. To read the body from the request, we need to look at a specific
header, called Content-Length which is included with the request. The
Content-Length header tells us the number of bytes (roughly equivalent with the
number of characters) that are included in the request body.

Once we find this number, we can use a special socket method read, to read that
specific number of bytes.

In short, then our process for reading the body of a post request looks like this:

Read the request headers by reading lines until we encounter a blank one
(same as before)
Find the Content-Length header and see how many bytes it says are included in
the request.
User Socket#read to read that number of bytes from the socket, thus reading the
request body.
For this iteration you’ll need to update your request handling to use this
process to read the request body for any POST requests your server receives.

Sending a Redirect
A Redirect is a special kind of HTTP response. It indicates to an HTTP client
that the resource they requested should be fetched from a different location.
A redirect is HTTP’s mechanism of telling a client (often a web browser) to
“go over there.” You’ve seen this on the web whenever you submit a web form and
your browser automatically loads a new page. Redirects are often used in response
to POST requests.

To respond with a redirect, you need to send 2 things:

A 3xx status code – in our case 302 will be the standard status code for
redirecting
A special header called Location – the Location header indicates the new URL
the browser should visit. For example the header Location: http://google.com
would tell a web browser to navigate to google’s homepage.
Here’s what the headers for an example redirect response would look like:

$ curl -I google.com
HTTP/1.1 301 Moved Permanently
Location: http://www.google.com/
Content-Type: text/html; charset=UTF-8
Date: Fri, 26 Feb 2016 01:55:24 GMT
Expires: Sun, 27 Mar 2016 01:55:24 GMT
Cache-Control: public, max-age=2592000
Server: gws
Content-Length: 219
X-XSS-Protection: 1; mode=block
X-Frame-Options: SAMEORIGIN


DELETE THIS FILE
